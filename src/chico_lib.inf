

!!==============================================================================
!!
!!	EL CHICO
!!	Personalizaciones de la librería Inform
!!
!!==============================================================================
!!
!!	File:			chico_lib.inf
!!	Author(s):		J. Francisco Martín <jfm.lisaso@gmail.com>
!!	Language:		ES (Castellano)
!!	System:			Inform-INFSP 6
!!	Platform:		Máquina-Z / GLULX
!!	Version:		1.1
!!	Release:		2015/02/07
!!
!!------------------------------------------------------------------------------
!!
!!	# HISTORIAL DE VERSIONES
!!
!!	1.1: 2015/02/07 Añadidas funciones _este(), _ese(), _aquel() para imprimir 
!!					los determinantes demostrativos adecuados para un obj.
!!	1.0: 2015/01/29	Versión original.
!!
!!------------------------------------------------------------------------------
!!
!!	This program is free software; you can redistribute it and/or modify
!!	it under the terms of the GNU General Public License as published by
!!	the Free Software Foundation; either version 2 of the License, or
!!	(at your option) any later version.
!!
!!	This program is distributed in the hope that it will be useful,
!!	but WITHOUT ANY WARRANTY; without even the implied warranty of
!!	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!	GNU General Public License for more details.
!!
!!	You should have received a copy of the GNU General Public License along
!!	with this program; if not, write to the Free Software Foundation, Inc.,
!!	51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. Or see
!!	<http://www.gnu.org/licenses/>.
!!
!!	Copyright (C) 2015, J. Francisco Martín
!!
!!------------------------------------------------------------------------------
!!
!!	# RUTINAS IMPLEMENTADAS:
!!
!!	 -	_o()
!!	 -	_este()
!!	 -	_ese()
!!	 -	_aquel()
!!	 -	AttemptToTakeObject()
!!	 -	Banner()
!!		 -	PrintVersionNumber()
!!		 -	PrintSerialNumber()
!!	 -	DrawStatusLine()
!!		 -	PrintLocationName()
!!	 -	GetGNAOfObject()
!!	 -	InvSub()
!!	 -	InvTallSub()
!!	 -	InvWideSub()
!!	 -	LMode1Sub()
!!	 -	LMode2Sub()
!!	 -	LMode3Sub()
!!	 -	LookSub()
!!	 -	ParseNoun()
!!	 -	PSN__()
!!	 -	SetGrammaticalInflection()
!!		 -	GrammarSub()
!!	 -	SpanishNominativePronoun()
!!	 -	VersionSub()	
!!
!!------------------------------------------------------------------------------


!!==============================================================================
!! Constantes y variables globales de la librería
!!------------------------------------------------------------------------------

Constant FIRST_PERSON_PRESENT	= 1;
Constant SECOND_PERSON_PRESENT	= 2;
Constant THIRD_PERSON_PRESENT	= 3;
Constant FIRST_PERSON_PAST		= 4;
Constant SECOND_PERSON_PAST		= 5;
Constant THIRD_PERSON_PAST		= 6;

Global _grammatical_inflection	= SECOND_PERSON_PRESENT;


!!==============================================================================
!! Imprime la terminación '-o', '-a', '-os', '-as' según el género y número del 
!! objeto pasado como parámetro, para hacer concordar los adjetivos. Si se 
!! invoca con el parámetro 'flag' activado ('true'), GetGNAOfObject() trata de 
!! devolver (si es que el objeto está definido apropiadamente) el GNA dado por 
!! su propiedad 'gender', en lugar de tener en cuenta los atributos 'animate', 
!! 'male', 'female' y 'pluralname'.
!!
!!	@params obj:Object
!!		objeto para el que se imprime la terminación '-o', '-a', '-os', '-as' 
!!		apropiada
!!	@retorna nada
!!------------------------------------------------------------------------------

[ _o obj
	gna;
	gna = GetGNAOfObject(obj, true);
	switch (gna) {
		0, 2, 6, 8:		print "o";
		1, 7:			print "a";
		3, 5, 9, 11:	print "os";
		4, 10:			print "as";
	}
];

!!==============================================================================
!! Funciones para imprimir los deternimantes demostrativos adecuados para el 
!! objeto pasado como parámetro.
!!
!!	@params obj:Object
!!		objeto para el que se imprime el determinante demostrativo apropiado
!!	@retorna nada
!!------------------------------------------------------------------------------

[ _este obj
	gna;
	gna = GetGNAOfObject(obj, true);
	switch (gna) {
		0, 6:			print "este";
		1, 7:			print "esta";
		2, 8:			print "esto";
		3, 5, 9, 11:	print "estos";
		4, 10:			print "estas";
	}
];

[ _ese obj
	gna;
	gna = GetGNAOfObject(obj, true);
	switch (gna) {
		0, 6:			print "ese";
		1, 7:			print "esa";
		2, 8:			print "eso";
		3, 5, 9, 11:	print "esos";
		4, 10:			print "esas";
	}
];

[ _aquel obj
	gna;
	gna = GetGNAOfObject(obj, true);
	switch (gna) {
		0, 6:			print "aquel";
		1, 7:			print "aquella";
		2, 8:			print "aquello";
		3, 5, 9, 11:	print "aquellos";
		4, 10:			print "aquellas";
	}
];


!!==============================================================================
!! Trata de transferir un objeto dado al jugador: retorna falso si la acción se 
!! realiza con éxito, verdadero si se produce algún error (imprimiendo un 
!! mensaje adecuado en este último caso).
!! [Sobreescribe a verblibm.h]
!!------------------------------------------------------------------------------
![ AttemptToTakeObject item     ancestor after_recipient i j k;
!	if (item == player) return L__M(##Take, 2);
!	if (item has animate) return L__M(##Take, 3, item);
!
!	ancestor = CommonAncestor(player, item);
!
!	if (ancestor == 0) {
!		i = ObjectScopedBySomething(item);
!		if (i ~= 0) ancestor = CommonAncestor(player, i);
!	}
!
!	!! Is the player indirectly inside the item?
!	if (ancestor == item) return L__M(##Take, 4, item);
!
!	!! Does the player already directly contain the item?
!	if (item in player) return L__M(##Take, 5, item);
!
!	!! Can the player touch the item, or is there (e.g.) a closed container 
!	!! in the way?
!	if (ObjectIsUntouchable(item, false, true)) return;
!
!	!! The item is now known to be accessible.
!
!	!! Consult the immediate possessor of the item, if it's in a container 
!	!! which the player is not in.
!
!	i = parent(item);
!	if (i && i ~= ancestor && (i has container || i has supporter)) {
!		after_recipient = i;
!		k = action; action = ##LetGo;
!		if (RunRoutines(i, before) ~= 0) { action = k; rtrue; }
!		action=k;
!	}
!
!	if (item has scenery) return L__M(##Take, 10, item);
!	if (item has static)  return L__M(##Take, 11, item);
!
!	!! En este punto se sabe que el objeto está en condiciones de ser cogido. 
!	!! Se comprueba ahora si el personaje lleva ya demasiados objetos consigo. 
!	!! Si es así y en caso de que sea posible, se trata de meter algún objeto 
!	!! en el SACK_OBJECT para hacer sitio en el inventario.
!
!	k = 0; objectloop (j in player) if (j hasnt worn) k++;
!
!	if (k >= ValueOrRun(player, capacity)) {
!		if (SACK_OBJECT ~= 0) {
!			!! XXX - Para introducir automáticamente algún objeto en el 
!			!! SACK_OBJECT, se comprueba que éste esté en posesión del 
!			!! personaje y lo lleve puesto. Esta segunda comprobación se ha 
!			!! añadido al relato dado que el SACK_OBJECT es la ropa del 
!			!! personaje (los bolsillos de su abrigo). Si el SACK_OBJECT fuese 
!			!! una mochila, por ejemplo, la comprobación sería innecesaria.
!			if (parent(SACK_OBJECT) ~= player || SACK_OBJECT hasnt worn)
!				return L__M(##Take, 12);
!			j = 0;
!			objectloop (k in player) 
!				if (k ~= SACK_OBJECT && k hasnt worn && k hasnt light 
!					!! XXX - Se comprueba además si el objeto cabe dentro o 
!					!! sobre SACK_OBJECT de forma que, si no lo hace, no se 
!					!! intenta introducirlo automáticamente. La rutina 
!					!! CheckIfObjectFits(receiver, obj) está definida dentro de 
!					!! la extensión "receptacles.h".
!					&& CheckIfObjectFits(SACK_OBJECT, k)) j = k;
!
!			if (j ~= 0) {
!				L__M(##Take, 13, j);
!				new_line;
!				keep_silent = 1; <Insert j SACK_OBJECT>; keep_silent = 0;
!				if (j notin SACK_OBJECT) rtrue;
!			}
!			else return L__M(##Take, 12);
!		}
!		else return L__M(##Take, 12);
!	}
!
!	!! Transfer the item.
!	move item to player;
!
!	!! Send "after" message to the object letting go of the item, if any.
!	if (after_recipient ~= 0) {
!		k = action; action = ##LetGo;
!		if (RunRoutines(after_recipient, after) ~= 0) { action = k; rtrue; }
!		action=k;
!	}
!	rfalse;
!];


!!==============================================================================
!! Rutinas para imprimir créditos generales de la aplicación en castellano.
!!
!!	@retorna nada
!!	@sobreescribe verblibm.h
!!------------------------------------------------------------------------------

[ Banner;
	if (Story ~= 0) {
		#Ifdef TARGET_ZCODE;
		#IfV5; style bold; #Endif;
		print (string) Story;
		#IfV5; style roman; #Endif;
		print (emph) " - ed. reducida";
		#Ifnot; ! TARGET_GLULX;
		glk($0086, 3); ! set header style
		print (string) Story;
		glk($0086, 0); ! set normal style
		#Endif; ! TARGET_
		new_line;
	}
	if (Headline ~= 0) {
		print (string) Headline;
		new_line;
	}
	#Ifdef DEBUG;
	#Ifdef BETA_RELEASE;
	print "BETA ";
	#Ifnot;
	print "ALFA ";
	#Endif; ! BETA_RELEASE;
	#Ifnot;
	print "Versión ";
	#Endif; ! DEBUG;
	PrintVersionNumber();
	print " / Núm. de serie ";
	PrintSerialNumber();
	print " / Creado con Inform "; inversion;
	#Ifdef DEBUG;
	print " ";
	#Endif; ! DEBUG;
	#Ifdef STRICT_MODE;
	print "S";
	#Endif; ! STRICT_MODE
	#Ifdef INFIX;
	print "X";
	#Endif; ! INFIX
!	#Ifdef DEBUG;
!	print "D";
!	#Endif; ! DEBUG
	new_line;
];

!! Imprime el número de versión
[ PrintVersionNumber
	i;
	i = 0;  ! shut up compiler warning
	print Checking, ".";
	#Ifdef	TARGET_ZCODE;
	print (HDR_GAMERELEASE-->0) & $03ff;
	#Ifnot;	! TARGET_GLULX;
	@aloads ROM_GAMERELEASE 0 i;
	print i;
	#Endif;	! TARGET_
];

!! Imprime el número de serie
[ PrintSerialNumber
	i;
	#Ifdef	TARGET_ZCODE;
	for (i=0 : i<6 : i++) print (char) HDR_GAMESERIAL->i;
	#Ifnot;	! TARGET_GLULX;
	for (i=0 : i<6 : i++) print (char) ROM_GAMESERIAL->i;
	#Endif;	! TARGET_
];


!!==============================================================================
!! Dibuja una barra de estado con el nombre de la localidad centrado. (NOTA: 
!! La barra de estado utilizada finalmente en el relato es en realidad una 
!! extensión de GWindows y no la barra de estado definida aquí, de manera que 
!! esta rutina queda inutilizada).
!!
!!	@retorna nada
!!	@sobreescribe parserm.h
!!------------------------------------------------------------------------------
!! Buffer auxiliar para calcular la longitud de un texto:
#Ifdef	VN_1630;	! compilador 6.30 o superior
Array _AlmacenDeTexto_ buffer 160; ! 150 y algo caracteres deberían bastar
#Ifnot;				! compiladores más viejos
Array	_AlmacenDeTexto_ -> 160 + WORDSIZE;
#Endif;	!VN_1630

[ DrawStatusLine
	width pos;
	#Ifdef TARGET_GLULX;
	! If we have no status window, we must not try to redraw it.
	if (gg_statuswin == 0) return;
	#Endif; ! TARGET_GLULX
	! If there is no player location, we should not try either.
	if (location == nothing || parent(player) == nothing) return;

	StatusLineHeight(gg_statuswin_size);
	MoveCursor(1, 1);
	width = ScreenWidth();
	spaces width;

	!! Primero calculamos la posición inicial para imprimir centrado.
	!! XXX - Si se cambia el nombre o el tamaño del buffer de texto temporal, 
	!! se deben cambiar también los dos primeros argumentos de PrintToBuffer().
	pos = (width - PrintToBuffer(_AlmacenDeTexto_, 160, PrintLocationName)) / 2;
	MoveCursor(1, pos); 	! se mueve el cursor a la posición calculada
	PrintLocationName();	! se imprime el nombre de la localidad

	MainWindow();
];

!! Imprime el nombre de la localidad en que se encuentra el personaje 
!! controlado por el usuario.
[ PrintLocationName;
	if (location == thedark) print (name) location;
	else {
		FindVisibilityLevels();
		if (visibility_ceiling == location) print (name) location;
		else print (The) visibility_ceiling;
	}
];


!!==============================================================================
!! Rutina para obtener la descripción de un objeto. Es idéntica a la rutina 
!! original implementada en verblibm.h salvo por una salvedad: al examinar un 
!! objeto por primera vez se le da el nuevo atributo 'described'.
!!
!!	@retorna booleano
!!	@sobreescribe verblibm.h
!!------------------------------------------------------------------------------
Attribute described; ! Indica si un objeto ha sido descrito al jugador

[ ExamineSub
	i;
	if (location == thedark) return L__M(##Examine, 1);
	i = noun.description;
	if (i == 0) {
		if (noun hasnt described) give noun described;
		if (noun has container) <<Search noun>>;
		if (noun has switchable) { L__M(##Examine, 3, noun); rfalse; }
		return L__M(##Examine, 2, noun);
	}
	PrintOrRun(noun, description);
	if (noun has switchable) L__M(##Examine, 3, noun);
	if (noun hasnt described) give noun described;
	if (AfterRoutines() == 1) rtrue;
];


!!==============================================================================
!! Determina el código GNA ('gender-number-animation') del nombre corto del 
!! objeto 'obj' pasado como parámetro.
!!
!!	@params obj:Object
!!		objeto del que se desea conocer su código GNA
!!	@params flag:booleano (opcional)
!!		si se invoca con este parámetro activado (==true), el GNA se elige 
!!		basándose en el atributo 'animate' y la propiedad 'gender' del objeto. 
!!		En caso contrario lo hace basándose en sus atributos 'animate', 'male', 
!!		'female', 'neuter' y 'pluralname'
!!	@returna entero
!! 		GNA del nombre corto del objeto. Se trata de un entero entre 0 y 11:
!!			 -	0	animate		singular	masculine
!!			 -	1							feminine
!!			 -	2							neuter
!!			 -	3				plural		masculine
!!			 -	4							feminine
!!			 -	5							neuter
!!			 -	6	inanimate	singular	masculine
!!			 -	7							feminine
!!			 -	8							neuter
!!			 -	9				plural		masculine
!!			 -	10							feminine
!!			 -	11							neuter
!!	@sobreescribe parserm.h
!!------------------------------------------------------------------------------

[ GetGNAOfObject obj flag
	result gen;
	result = 0;
	if (obj hasnt animate) result = 6;
	if (flag && obj provides gender) {
		switch (obj.gender) {
			1:	gen = male;
			2:	gen = female;
			3:	gen = male; result = result + 3;
			4:	gen = female; result = result + 3;
		}
	} else {
		if (obj has male) gen = male;
		if (obj has female) gen = female;
		if (obj has neuter) gen = neuter;
		if (obj has pluralname) result = result + 3;
	}
	if (gen == 0) {
		if (result == 0) gen = LanguageAnimateGender;
		else gen = LanguageInanimateGender;
	}
	!if (gen == male)	result = result + 0; ! Masculino: (0,3,6,9)
	if (gen == female)	result = result + 1; ! Femenino: (1,4,7,10)
	if (gen == neuter)	result = result + 2; ! Neutro: (2,5,8,11)

	return result;
];


!!==============================================================================
!! Rutinas para tomar inventario del protagonista.
!! [Sobreescribe a verblibm.h]
!!------------------------------------------------------------------------------
![ InvSub item number_worn number_carried first_worn;
!
!	!! El protagonista no lleva ningún objeto en el inventario
!	if (child(player) == 0) return L__M(##Inv, 1);
!
!	objectloop (item in player) {
!		if (item has worn) {
!			give item workflag;
!			number_worn++; 
!			if (number_worn == 1) first_worn = item;
!		} else { 
!			give item ~workflag; 
!			number_carried++;
!		}
!	}
!
!	!! XXX - La rutina ParseNoun (tanto la rutina original de SpanishG.h como 
!	!! la versión utilizada aquí) puede modificar temporalmente los atributos 
!	!! female y pluralname de un objeto en función del nombre que haya 
!	!! utilizado el interlector para referirse a él, con lo que su GNA cambia. 
!	!! Esto podía provocar un resultado inadecuado en la primera línea del 
!	!! inventario (imprimir cosas como "Lleva puesto su ropa..."). Para 
!	!! corregirlo se han añadido la rutina _o() y una pequeña modificación de 
!	!! GetGNAOfObject().
!
!	!! Objetos que el protagonista lleva puestos
!	if (number_worn ~= 0) {
!		switch (_grammatical_inflection) {
!			1:	print "Llevo puest",	(_o) first_worn, " ";
!			2:	print "Llevas puest",	(_o) first_worn, " ";
!			3:	print "Lleva puest",	(_o) first_worn, " ";
!			4:	print "Llevaba puest",	(_o) first_worn, " ";
!			5:	print "Llevabas puest",	(_o) first_worn, " ";
!			6:	print "Llevaba puest",	(_o) first_worn, " ";
!		}
!
!		!! XXX Apuntar que no se toma inventario de los objetos que pueda 
!		!! haber dentro de aquellos que el protagonista lleva puestos.
!		WriteListFrom(child(player), ENGLISH_BIT + WORKFLAG_BIT);
!
!		!! El protagonista tiene cosas en las manos además
!		if (number_carried ~= 0) {
!			objectloop (item in player) {
!				if (item has worn) give item ~workflag;
!				else give item workflag;
!			}
!			switch (_grammatical_inflection) {
!				1:	print ", y tengo además ";
!				2:	print ", y tienes además ";
!				3:	print ", y tiene además ";
!				4:	print ", y tenía además ";
!				5:	print ", y tenías además ";
!				6:	print ", y tenía además ";
!			}
!			WriteListFrom(child(player), 
!				ENGLISH_BIT + RECURSE_BIT + FULLINV_BIT + WORKFLAG_BIT);
!			print " en las manos";
!		}
!
!		if (SACK_OBJECT && SACK_OBJECT in player && SACK_OBJECT has worn) {
!			!! Lleva puesto el SACK_OBJECT y NO tiene nada en su interior:
!			if (~~child(SACK_OBJECT)) {
!				switch (_grammatical_inflection) {
!					1:	print ". En ", (el) SACK_OBJECT, " no llevo nada.";
!					2:	print ". En ", (el) SACK_OBJECT, " no llevas nada.";
!					3:	print ". En ", (el) SACK_OBJECT, " no lleva nada.";
!					4:	print ". En ", (el) SACK_OBJECT, " no llevaba nada.";
!					5:	print ". En ", (el) SACK_OBJECT, " no llevabas nada.";
!					6:	print ". En ", (el) SACK_OBJECT, " no llevaba nada.";
!				}
!			}
!			!! Lleva puesto el SACK_OBJECT y tiene cosas en su interior:
!			else {
!				switch (_grammatical_inflection) {
!					1:	print ". En ", (el) SACK_OBJECT, " guardo ";
!					2:	print ". En ", (el) SACK_OBJECT, " guardas ";
!					3:	print ". En ", (el) SACK_OBJECT, " guarda ";
!					4:	print ". En ", (el) SACK_OBJECT, " guardaba ";
!					5:	print ". En ", (el) SACK_OBJECT, " guardabas ";
!					6:	print ". En ", (el) SACK_OBJECT, " guardaba ";
!				}
!				WriteListFrom(child(SACK_OBJECT), 
!					ENGLISH_BIT + RECURSE_BIT + FULLINV_BIT);
!			}
!		}
!		print ".^";
!	}
!
!	!! El protagonista no lleva ningún objeto puesto
!	else {
!		switch (_grammatical_inflection) {
!			1:	print "Tengo ";
!			2:	print "Tienes ";
!			3:	print "Tiene ";
!			4:	print "Tenía ";
!			5:	print "Tenías ";
!			6:	print "Tenía ";
!		}
!		WriteListFrom(child(player), ENGLISH_BIT + RECURSE_BIT + FULLINV_BIT);
!		print " en las manos.^";
!	}
!
!	#Ifndef MANUAL_PRONOUNS;
!	objectloop (x in player) PronounNotice(x);
!	#Endif;
!	AfterRoutines();
!];
![ InvTallSub; <Inv>; ];
![ InvWideSub; <Inv>; ];


!!==============================================================================
!! Redefinición de los 'lookmode': Breve, Largo y Superbreve. 
!!
!!	@retorna nada
!!	@sobreescribe verblibm.h
!!------------------------------------------------------------------------------
[ LMode1Sub; lookmode = 1; L__M( ##LMode1 ); ];	! Breve
[ LMode2Sub; lookmode = 2; L__M( ##LMode2 ); ];	! Largo (ahora por defecto)
[ LMode3Sub; lookmode = 3; L__M( ##LMode3 ); ];	! Superbreve


!!==============================================================================
!! Redefinición de la rutina LookSub para evitar que se imprima el nombre de la 
!! localidad actual antes de su descripción.
!!
!!	@retorna nada
!!	@sobreescribe verblibm.h
!!------------------------------------------------------------------------------

[ LookSub allow_abbrev  visibility_levels i j k nl_flag;
	if (parent(player) == 0) return RunTimeError(10);

	.MovedByInitial;

	if (location == thedark) { visibility_ceiling = thedark; NoteArrival(); }
	else {
		visibility_levels = FindVisibilityLevels();
		if (visibility_ceiling == location) {
			NoteArrival();
			if (visibility_ceiling ~= location) jump MovedByInitial;
		}
	}

!	! Printing the top line: e.g.
!	! Octagonal Room (on the table) (as Frodo)
!	new_line;
!	#Ifdef TARGET_ZCODE;
!	style bold;
!	#Ifnot; ! TARGET_GLULX;
!	glk($0086, 4); ! set subheader style
!	#Endif; ! TARGET_
!	if (visibility_levels == 0) print (name) thedark;
!	else {
!		if (visibility_ceiling ~= location) print (The) visibility_ceiling;
!		else print (name) visibility_ceiling;
!	}
!	#Ifdef TARGET_ZCODE;
!	style roman;
!	#Ifnot; ! TARGET_GLULX;
!	glk($0086, 0); ! set normal style
!	#Endif; ! TARGET_
!	for (j=1,i=parent(player) : j<visibility_levels : j++,i=parent(i))
!		if (i has supporter) L__M(##Look, 1, i);
!		else                 L__M(##Look, 2, i);
!	if (print_player_flag == 1) L__M(##Look, 3, player);
!	new_line;

	! The room description (if visible)
	if (lookmode < 3 && visibility_ceiling == location) {
		if ((allow_abbrev ~= 1) || (lookmode == 2) 
			|| (location hasnt visited)) {
			if (location.&describe ~= 0) RunRoutines(location, describe);
			else {
				if (location.description == 0) RunTimeError(11, location);
				else PrintOrRun(location, description);
			}
		}
	}

	if (visibility_ceiling == location) nl_flag = 1;
	if (visibility_levels == 0) Locale(thedark);
	else {
		for (i=player,j=visibility_levels : j>0: j--,i=parent(i))
			give i workflag;
		for (j=visibility_levels : j>0 : j--) {
			for (i=player,k=0 : k<j : k++) i=parent(i);
			if (i.inside_description ~= 0) {
				if (nl_flag) new_line; else nl_flag = 1;
				PrintOrRun(i,inside_description); }
			if (Locale(i)~=0) nl_flag=1;
		}
	}

	LookRoutine();
	ScoreArrival();
	action = ##Look;
	if (AfterRoutines() == 1) rtrue;
];


!!==============================================================================
!! La rutina ParseNoun se ocupa de ignorar "de" cuando aparece entre dos 
!! palabras reconocidas como names de un mismo objeto. Así, si un objeto tiene 
!! en su campo "name" los valores "caja" "madera" "caoba" ParseNoun aceptará 
!! "caja de madera" "caja de caoba" e incluso "caja de madera de caoba". En 
!! cambio, ante la cadena "caja de bolsa", sólo aceptará la primera palabra 
!! (caja) dejando sin procesar "de bolsa", lo que permite la posterior 
!! interpretacion de frases como "saca caja de bolsa" e incluso "saca caja de 
!! madera de caoba de bolsa". De paso también ignora artículos con lo que 
!! también se admite: "saca la caja de madera de caoba de la bolsa".
!!
!! ParseNoun debe retornar un número que indica cuántas palabras admite como 
!! pertenecientes al objeto. En nuestro ejemplo, ante "caja de madera" debe 
!! retornar 3, pero ante "caja de bolsa" debe retornar 1.
!!
!! MODIFICACIÓN: Si usamos la rutina original y redefinimos el objeto con el 
!! valor "caja" en sus campos "name" (name, name_m, name_f, name_mp y name_fp) 
!! y los valores "madera" y "caoba" en el campo "adjectives", ParseNoun 
!! aceptaría las cadenas "caja", "caja de madera", "caja de madera de caoba", 
!! "madera", "caoba",... para referirse al objeto. Con la rutina modificada se 
!! permite hacer parseado estricto de forma que las cadenas "madera" y "caoba" 
!! no sean cadenas válidas. Es decir, de manera que sea precisa la existencia 
!! de al menos una coincidencia con los valores de los campos "name" del 
!! objeto.
!!
!!	@retorna entero
!!		número de palabras reconocidas en la entrada del usuario
!!	@sobreescribe SpanishG.h
!!------------------------------------------------------------------------------
[ ParseNoun obj n dudas seguir gen p aux m nm nf nmp nfp a;

	n	= 0;	! núm. de palabras reconocidas de momento
	m	= 0;	! núm. de nombres reconocidos de momento
	nm	= 0;	! núm. de nombres masculinos reconocidos de momento
	nf	= 0;	! núm. de nombres femeninos reconocidos de momento
	nmp	= 0;	! núm. de nombres masculinos plurales reconocidos de momento
	nfp	= 0;	! núm. de nombres femeninos plurales reconocidos de momento
	a	= 0;	! núm. de adjetivos reconocidos de momento

	! Indica si hay que seguir mirando palabras para comprobar si las 
	! siguientes se refieren o no a este mismo objeto
	seguir = 1;

	aux = aux;
	#ifdef DEBUG;
	aux = debug_flag;
	! Se desactiva el trazado de give
	! (para no cansar con tanto "nombreusado" cambiando continuamente)
	debug_flag = 0;
	#endif;
	give obj ~nombreusado; ! resetear nombreusado (quitar nombreusado)
	gen = 5;
	! 1=masculino,		  2=femenino,
	! 3=masculino plural, 4=femenino plural
	! 5=sin determinar

	while (seguir)
	{
		p = NextWord();
		if ((p=='de') && (n==0)) return 0;

		if (WordInProperty (p, obj, name_f))
		! Una palabra que se refiere al objeto
		{
			if (p) dict_flags_of_noun = (p->#dict_par1) & $$01110100;
			if (gen==5) gen = G_FEMENINO;
			n++;		! la contamos
			m++;
			nf++;
			n=n+dudas;	! añadimos todos los "de" "la"... que estaban sin contar
			dudas=0;	! y resetamos el contador de "de"s
!			print " --> es ahora femenino...." ; !infsp debug
			continue;	! volvemos al while
		}
		if (WordInProperty (p, obj, name_mp))
		! Una palabra que se refiere al objeto
		{
			if (p) dict_flags_of_noun = (p->#dict_par1) & $$01110100;
			if (gen==5) gen=G_MASCULINO+G_PLURAL;
			n++;		! la contamos
			m++;
			nmp++;
			n=n+dudas;	! añadimos todos los "de" "la"... que estaban sin contar
			dudas=0;	! y resetamos el contador de "de"s
			continue;	! volvemos al while
		}
		if (WordInProperty(p, obj, name_fp))
		! Una palabra que se refiere al objeto
		{
			if (p) dict_flags_of_noun = (p->#dict_par1) & $$01110100;
			if (gen==5) gen=G_FEMENINO+G_PLURAL;
			n++;		! la contamos
			m++;
			nfp++;
			n=n+dudas;	! añadimos todos los "de" "la"... que estaban sin contar
			dudas=0;	! y resetamos el contador de "de"s
			continue;	! volvemos al while
		}
		! [I7] se cambio de lugar este if para buscar el name_m (o name)
		! en ultimo lugar, debido a una interferencia q provoca la asignacion 
		! 'automatica' de plural en los objetos I7
		if (WordInProperty(p, obj, name_m))
		! Una palabra que se refiere al objeto
		{
			if (p) dict_flags_of_noun = (p->#dict_par1) & $$01110100;
			if (gen==5) gen=G_MASCULINO;
			n++;		! la contamos
			m++;
			nm++;
			n=n+dudas;	! añadimos todos los "de" "la"... que estaban sin contar
			dudas=0;	! y resetamos el contador de "de"s
!			print " --> es ahora masculino...." ; !infsp debug
			continue;	! volvemos al while
		}
		if (WordInProperty(p, obj, adjectives))
		{
			if (p) dict_flags_of_noun = (p->#dict_par1) & $$01110100;
			n++;		! la contamos
			a++;
			n=n+dudas;	! añadimos todos los "de" "la"... que estaban sin contar
			dudas = 0;	! y resetamos el contador de "de"s
!			print (the) obj," --> adjetivo detectado....^" ; !infsp debug
			continue;	! volvemos al while
		}
				
		! Si la palabra no fue reconocida, miraremos si se trata
		! de 'de' o un artículo. En este caso mantenemos la duda y
		! seguimos mirando palabras, hasta que una de ellas encaje
		! en este objeto$ en cuyo caso se retornan todas las que se
		! han leido, o bien se encuentre una que no encaja en cuyo
		! caso se retorna las que se habían encontrado antes del "de"

		else if (p== 'el' or 'la' or 'los' or 'las' or 'de')
		{
			dudas++; continue;
		}
		! Si la palabra no fue reconocida, ni se trata de un artículo o de un 
		! "de", se da la búsqueda por finalizada y se sale del bucle
		else seguir = 0;

	}! while block

	if (obj provides gender) {
		switch (gen) {
			1: give obj ~female ~pluralname;
			2: give obj female ~pluralname;
			3: give obj ~female pluralname;
			4: give obj female pluralname;
		}
	}

	! Si el matcheo fue por adjectives, entonces gen = 5 y "nombresusado" no 
	! se han puesto
	if (gen < 5) give obj nombreusado;

	#ifdef DEBUG;
	debug_flag=aux;
	#endif;

	! En caso de que estemos usando parseado estricto, despreciamos el objeto 
	! si no ha sido referenciado al menos por uno de sus nombres
	if (m == 0) return 0;

	return n; ! Se retorna número de palabras reconocidas
];


!!==============================================================================
!! Rutina para imprimir el nombre corto de un objeto. Además, crea un 
!! hipervínculo relacionado con el objeto y, si el objeto tiene el atributo 
!! 'remarkable' utiliza un estilo resaltado para imprimir el nombre.
!!
!!	@retorna verdadero
!!	@sobreescribe parserm.h
!!------------------------------------------------------------------------------
[ PSN__ obj;
	if (obj == 0) { print (string) NOTHING__TX; rtrue; }
	switch (metaclass(obj)) {
		Routine:  print "<routine ", obj, ">"; rtrue;
		String:   print "<string ~", (string) obj, "~>"; rtrue;
		nothing:  print "<illegal object number ", obj, ">"; rtrue;
	}
	#Ifdef LanguagePrintShortName;
	if (LanguagePrintShortName(obj)) rtrue;
	#Endif; ! LanguagePrintShortName
	return CreateLink(obj);
];


!!==============================================================================
!! Establece la flexión gramatical de los mensajes de la librería.
!!
!!	@retorna nada
!!------------------------------------------------------------------------------
[ SetGrammaticalInflection gi;
	switch (gi) {
	FIRST_PERSON_PRESENT:
		_grammatical_inflection = FIRST_PERSON_PRESENT;
		FORMER__TX		= "mi antiguo ~yo~";
		CANTGO__TX		= "No puedo ir por ahí.";
		IS__TX			= " veo";
		ARE__TX			= " veo";
		IS2__TX			= "veo ";
		ARE2__TX		= "veo ";
		YOU__TX			= "Yo";
		PARTICULA_TE	= "me";
		if (player has female || 
			(player provides gender && player.gender == G_FEMENINO)) { 
			YOURSELF__TX	= "mi misma";
		} else {
			YOURSELF__TX	= "mi mismo";
		}
	SECOND_PERSON_PRESENT:
		_grammatical_inflection = SECOND_PERSON_PRESENT;
		FORMER__TX		= "tu antiguo ~yo~";
		CANTGO__TX		= "No puedes ir por ahí.";
		IS__TX			= " ves";
		ARE__TX			= " ves";
		IS2__TX			= "ves ";
		ARE2__TX		= "ves ";
		YOU__TX			= "Tú";
		PARTICULA_TE	= "te";
		if (player has female || 
			(player provides gender && player.gender == G_FEMENINO)) { 
			YOURSELF__TX	= "ti misma";
		} else {
			YOURSELF__TX	= "ti mismo";
		}
	THIRD_PERSON_PRESENT:
		_grammatical_inflection = THIRD_PERSON_PRESENT;
		FORMER__TX    = "su antiguo ~yo~";
		CANTGO__TX    = "No puede ir por ahí.";
		IS__TX        = " ve";
		ARE__TX       = " ve";
		IS2__TX       = "ve ";
		ARE2__TX      = "ve ";
		PARTICULA_TE  = "se";
		if (player has female || 
			(player provides gender && player.gender == G_FEMENINO)) { 
			YOURSELF__TX  = "si misma";
			YOU__TX       = "Ella";
		} else {
			YOURSELF__TX  = "si mismo";
			YOU__TX       = "Él";
		}
	FIRST_PERSON_PAST:
		_grammatical_inflection = FIRST_PERSON_PAST;
		FORMER__TX		= "mi antiguo ~yo~";
		CANTGO__TX		= "No podía ir por ahí.";
		IS__TX			= " veía";
		ARE__TX			= " veía";
		IS2__TX			= "veía ";
		ARE2__TX		= "veía ";
		YOU__TX			= "Yo";
		PARTICULA_TE	= "me";
		if (player has female || 
			(player provides gender && player.gender == G_FEMENINO)) { 
			YOURSELF__TX	= "mi misma";
		} else {
			YOURSELF__TX	= "mi mismo";
		}
	SECOND_PERSON_PAST:
		_grammatical_inflection = THIRD_PERSON_PAST;
		FORMER__TX		= "tu antiguo ~yo~";
		CANTGO__TX		= "No podías ir por ahí.";
		IS__TX			= " veías";
		ARE__TX			= " veías";
		IS2__TX			= "veías ";
		ARE2__TX		= "veías ";
		YOU__TX			= "Tú";
		PARTICULA_TE	= "te";
		if (player has female || 
			(player provides gender && player.gender == G_FEMENINO)) { 
			YOURSELF__TX	= "ti misma";
		} else {
			YOURSELF__TX	= "ti mismo";
		}
	THIRD_PERSON_PAST:
		_grammatical_inflection = THIRD_PERSON_PAST;
		FORMER__TX    = "su antiguo ~yo~";
		CANTGO__TX    = "No podía ir por ahí.";
		IS__TX        = " veía";
		ARE__TX       = " veía";
		IS2__TX       = "veía ";
		ARE2__TX      = "veía ";
		PARTICULA_TE  = "se";
		if (player has female || 
			(player provides gender && player.gender == G_FEMENINO)) { 
			YOURSELF__TX  = "si misma";
			YOU__TX       = "Ella";
		} else {
			YOURSELF__TX  = "si mismo";
			YOU__TX       = "Él";
		}
	default:
		StartParserStyle();
		print "SetGrammaticalInflection() ERROR. El parámetro ", gi, " no es un 
		parámetro válido de la función.";
		EndParserStyle();
		new_line;
		return false;
	}
	ChangeDefault(cant_go, CANTGO__TX);
];

#Ifdef	DEBUG;
Verb	meta 'gramatica' 'grammar'
	*								-> Grammar
	* number						-> Grammar;
[ GrammarSub;
	StartParserStyle();
	switch (noun) {
		1:	SetGrammaticalInflection(FIRST_PERSON_PRESENT); 
			print "Cambio de flexión gramatical: ";
		2:	SetGrammaticalInflection(SECOND_PERSON_PRESENT);
			print "Cambio de flexión gramatical: ";
		3:	SetGrammaticalInflection(THIRD_PERSON_PRESENT); 
			print "Cambio de flexión gramatical: ";
		4:	SetGrammaticalInflection(FIRST_PERSON_PAST); 
			print "Cambio de flexión gramatical: ";
		5:	SetGrammaticalInflection(SECOND_PERSON_PAST); 
			print "Cambio de flexión gramatical: ";
		6:	SetGrammaticalInflection(THIRD_PERSON_PAST); 
			print "Cambio de flexión gramatical: ";
		default:
			print "Flexión gramatical actual: ";
	}
	switch (_grammatical_inflection) {
		FIRST_PERSON_PRESENT:	print "(1) presente 1a persona";
		SECOND_PERSON_PRESENT:	print "(2) presente 2a persona";
		THIRD_PERSON_PRESENT:	print "(3) presente 3a persona";
		FIRST_PERSON_PAST:		print "(4) pasado 1a persona";
		SECOND_PERSON_PAST:		print "(5) pasado 2a persona";
		THIRD_PERSON_PAST:		print "(6) pasado 3a persona";
	}
	print ".";
	EndParserStyle();
	new_line;
	return true;
];
#Endif; ! DEBUG;


!!==============================================================================
!! Imprime el pronombre nominativo correcto correspondiente a un objeto.
!!
!!	@param obj:Object
!!		objeto del que se desea imprimir su pronombre nominativo
!!	@returna nada
!!------------------------------------------------------------------------------
[ SpanishNominativePronoun obj;
	switch (GetGNAOfObject (obj, true)) {
		0, 6:	print "él";
		1, 7:	print "ella";
		2, 8:	print "ello";
		3, 9:	print "ellos";
		4, 10:	print "ellas";
		5, 11:	print "ellos";
   }
];


!!==============================================================================
!! Créditos detallados de la aplicación.
!!
!!	@retorna nada
!!	@sobreescribe verblibm.h
!!------------------------------------------------------------------------------
[ VersionSub ix;
	new_line;
	Banner();
	print "Versión de la librería Inform ", (string) LibRelease;
	print " / Núm. de serie librería ", (string) LibSerial;
	new_line;
	#Ifdef LanguageVersion;
	print (string) LanguageVersion, "^";
	#Endif; ! LanguageVersion
	#Ifdef TARGET_ZCODE;
	ix = 0; ! shut up compiler warning
	if (standard_interpreter > 0) {
		print "Estándar del intérprete ", standard_interpreter/256, ".", 
			standard_interpreter%256, " (", HDR_TERPNUMBER->0;
		#Iftrue (#version_number == 6);
		print (char) '.', HDR_TERPVERSION->0;
		#Ifnot;
		print (char) HDR_TERPVERSION->0;
		#Endif;
		print ") / ";
	} else {
		print "Intérprete ", HDR_TERPNUMBER->0, " Versión ";
		#Iftrue (#version_number == 6);
		print HDR_TERPVERSION->0;
		#Ifnot;
		print (char) HDR_TERPVERSION->0;
		#Endif;
		print " / ";
	}
	#Ifnot; ! TARGET_GLULX;
	@gestalt 1 0 ix;
	print "Versión del intérprete ", ix / $10000, ".", (ix & $FF00) / $100,
	".", ix & $FF, " / ";
	@gestalt 0 0 ix;
	print "VM ", ix / $10000, ".", (ix & $FF00) / $100, ".", ix & $FF;
	#Endif; ! TARGET_;
	new_line;
];


